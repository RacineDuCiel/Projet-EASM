from typing import List, Optional, Union, Dict, Any
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from src.models.asset import Vulnerability, Asset
from src.models.program import Scope
from src.schemas.asset import VulnerabilityCreate, Vulnerability as VulnerabilitySchema
from src.models.enums import Severity, VulnStatus

class CRUDVulnerability:
    async def get(self, db: AsyncSession, id: UUID) -> Optional[Vulnerability]:
        return await db.get(Vulnerability, id)

    async def get_with_program(self, db: AsyncSession, id: UUID) -> Optional[Vulnerability]:
        """Get vulnerability with eager-loaded asset and scope for authorization checks."""
        from sqlalchemy.orm import selectinload

        query = (
            select(Vulnerability)
            .where(Vulnerability.id == id)
            .options(
                selectinload(Vulnerability.asset)
                .selectinload(Asset.scope)
            )
        )
        result = await db.execute(query)
        return result.scalar_one_or_none()

    async def get_multi(
        self,
        db: AsyncSession,
        *,
        skip: int = 0,
        limit: int = 100,
        program_id: Optional[UUID] = None,
        severity: Optional[Severity] = None,
        status: Optional[VulnStatus] = None,
        asset_id: Optional[UUID] = None,
        search: Optional[str] = None
    ) -> List[Vulnerability]:
        query = select(Vulnerability)
        
        # Joins needed for filtering by program_id
        if program_id:
            query = query.join(Asset).join(Scope).where(Scope.program_id == program_id)
        
        if severity:
            query = query.where(Vulnerability.severity == severity)
            
        if status:
            query = query.where(Vulnerability.status == status)
            
        if asset_id:
            query = query.where(Vulnerability.asset_id == asset_id)
            
        if search:
            query = query.where(Vulnerability.title.ilike(f"%{search}%"))
            
        query = query.offset(skip).limit(limit).order_by(Vulnerability.created_at.desc())
        
        result = await db.execute(query)
        return result.scalars().all()

    async def get_count(
        self,
        db: AsyncSession,
        *,
        program_id: Optional[UUID] = None,
        severity: Optional[Severity] = None,
        status: Optional[VulnStatus] = None,
        asset_id: Optional[UUID] = None,
        search: Optional[str] = None
    ) -> int:
        query = select(func.count()).select_from(Vulnerability)
        
        if program_id:
            query = query.join(Asset).join(Scope).where(Scope.program_id == program_id)
            
        if severity:
            query = query.where(Vulnerability.severity == severity)
            
        if status:
            query = query.where(Vulnerability.status == status)
            
        if asset_id:
            query = query.where(Vulnerability.asset_id == asset_id)

        if search:
            query = query.where(Vulnerability.title.ilike(f"%{search}%"))
            
        return await db.scalar(query)

    async def update(
        self,
        db: AsyncSession,
        *,
        db_obj: Vulnerability,
        obj_in: Union[Dict[str, Any], VulnerabilitySchema]
    ) -> Vulnerability:
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.model_dump(exclude_unset=True)
            
        for field in update_data:
            if hasattr(db_obj, field):
                setattr(db_obj, field, update_data[field])
                
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

vulnerability = CRUDVulnerability()
